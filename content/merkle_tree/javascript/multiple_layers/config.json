{
  "_id": "5ba156c2d9f997cd2e33ebac",
  "_type": "CodeStage",
  "code_file_ids": [
    "5ba15643d9f997cd2e33ebaa",
    "5ba1562ad9f997cd2e33eba9",
    "5ba156e4d9f997cd2e33ebad"
  ],
  "completion_message": "## We're so impressed by you we wrote this sentence\n\nWe're so impressed by you we wrote (We're so impressed by you we wrote (We're so impressed by you we wrote ...))\n\nWhoops. No base case, we overflowed. :)\n\nOnto odd Merkle Trees! ",
  "container_id": "5ba1558bd9f997cd2e33eba7",
  "details": "## The Goal \n\n**What's the goal of writing a tree structure of hash combinations?**\n\nConsider the four leaf example:\n\n```\n    Root\n    /  \\ \n   AB  CD\n  / \\  / \\\n  A B  C D\n```\n\nBecause `CD` is a combination of `C` and `D` and the `Root` is a combination of `AB` and `CD`, we can see that the hash `C` will directly affect the resulting hash in the `Root`. From `C`'s perspective all we need to know is `D` and `AB` to create the `Root`:\n\n```\nHash(AB, Hash(C, D)) == Root\n```\n\nNotice that, in this equation, we can completely forget about `A` and `B`. We don't need to know what they are to prove that `C` is in the `Root`. We just need the hashes `D` and `AB`.  \n\nThis optimization is the power of Merkle Trees and it becomes even more apparent with larger trees where less data is necessary to prove that a leaf node is part of the tree. \n\n## Recommended Approach\n\nThere's a few ways to attempt writing this algorithm. The most elegant solutions are likely recursive. This doesn't necessarily mean that you can't attempt it iteratively! Either way, let's break down the thought process on how to approach this.\n\nWe have a merkle tree with some arbitrary number of leaf nodes. Maybe it's the four leaf tree: \n\n```\n    Root\n    /  \\ \n   AB  CD\n  / \\  / \\\n  A B  C D\n```\n\nMaybe it's the eight leaf tree: \n\n```\n        Root\n       /    \\\n    ABCD     EFGH\n    / \\      / \\\n   AB  CD   EF  GH\n  / \\  / \\  / \\ / \\\n  A B  C D  E F G H\n```\n\nOur recommended approach to this problem, is to break it down into layers. For each layer, we want to go through every 2 nodes and concatenate them. \n\nSo, if we're on the bottom layer, we want to take `A` and `B` and concatenate them to make `AB`, `C` and `D` to make `CD` and so on until we have four nodes `AB`, `CD`, `EF`, `GH`. \n\nOnce we've done that, we'll move up to the next layer and do the same. Concatenate `AB` and `CD` to get `ABCD`. Concatenate `EF` and `GH` to make `EFGH`. \n\nWe'll repeat this one more time, for the last layer to get our merkle root `ABCDEFGH`. \n\nWe could preemptively calculate how many layers we need to reduce, or we could keep an array of nodes and when it's `length` is one we know we've reached the merkle root. \n\nIt's up to you how to solve it. Make sure you consider the algorithm for each layer as well as your exit condition carefully!",
  "language": "javascript",
  "language_version": "8.x/babel",
  "position": 1,
  "task": "## Multiple Layers\n\nAwesome! Now it's time to create a larger Merkle Tree.\n\n### Four Leaf Tree\n\nNow we need to make sure to handle a case where there are multiple layers of hashing. First we hash together `A` and `B`, then we hash together `C` and `D`. Then we hash together the combination of `A` and `B` (`AB`) with the combination of `C` and `D` (`CD`). Something like this:\n\n```\n    Root\n    /  \\ \n   AB  CD\n  / \\  / \\\n  A B  C D\n```\n\nTo do this is may be useful to think of the tree as having multiple layers, where the first layer is the leaves (`A`, `B`, `C`, `D`) the second is the combination of both of those branches (`AB`, `CD`) and then we reach our Merkle Root or the combination of all branches (`ABCD`). \n\nIt may be helpful to remember [what we're trying to accomplish](?tab=details&scroll=The%20Goal) by hashing at multiple layers. \n\nThis is a tough algorithm to work through. If you need help getting started check out our [Recommended Approach](?tab=details&scroll=Recommended%20Approach).",
  "test_framework": "mocha_bdd",
  "title": "Multiple Layers",
  "updated_at": "2018-10-16T01:50:10.148Z",
  "created_at": "2018-10-16T01:50:10.148Z"
}