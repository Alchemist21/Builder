{
  "_id": "5ba541ac929d249ffe9529a9",
  "_type": "CodeStage",
  "code_file_ids": [
    "5ba541c7929d249ffe9529aa",
    "5ba1562ad9f997cd2e33eba9",
    "5ba15643d9f997cd2e33ebaa"
  ],
  "completion_message": "## You have *proved* your worth!\n\nNow let's write the necessary code to verify the node belongs in the tree. ",
  "container_id": "5ba1558bd9f997cd2e33eba7",
  "details": "## Another Example\n\nLet's prove A belongs in the ABCDEFGHIJ Merkle Tree\n```\n                Root\n              /      \\\n      ABCDEFGH        IJ\n      /      \\         |\n    ABCD     EFGH     IJ\n    / \\      /   \\     |\n   AB  CD   EF   GH   IJ\n  / \\  / \\  / \\  / \\  / \\      \n  A B  C D  E F  G H  I J\n```\n\nIn order to prove A is in this tree we'll need the following proof path:\n\n```\nHash(Hash(Hash(Hash(A + B) + CD) + EFGH) + IJ)\n```\n\nSo we'll need four hashes: `B`, `CD`, `EFGH`, and `IJ`.\n\n```\n[\n { data: 'B', left: false },\n { data: 'CD', left: false },\n { data: 'EFGH', left: false }\n { data: 'IJ', left: false }\n]\n```\n\nSuch a big tree and we only need four hashes to prove `A`! For `I` or `J` the savings would be even better in this tree, only two hashes necessary for their proofs. Very cool!\n\n## Recommended Approach\n\nThis is a difficult algorithm to come up with, so we've included a recommended approach. \n\nYou'll want to approach this similar to how you did the `getRoot` algorithm. If you think of the algorithm in terms of layers, we can figure out what need to do on each layer.\n\nLet's use the ABCDE Merkle Tree for an example:\n\n```\n      Root\n     /   \\\n   ABCD   E\n   / \\    |\n  AB  CD  E\n / \\  / \\ |\n A B  C D E\n```\n\nLet's say we want to prove C exists in the tree. We're given the index 2, which corresponds to the C's position in the array passed into our Merkle Tree constructor. \n\nSo we start at `C` on the bottom layer. What do we need to first? \n\nWe need to know if `C` is the left or right node in its pairing. We can determine this by checking `C`'s index (2). Two is even so it is a left node. Now that we know that, we need to add one to our index to get the right node: `D`. We add `D` to our proof and say it is `left: false` (because it's on the right).\n\nOur proof so far: `[{ data: 'D', left: false }]`\n\nNext we need to move up a layer. Since we started at `C` and we have `D` in our proof, we have what we need to make hash `CD`. That means we want to go from our current index 2, to index 1. Since our merkle tree is a binary tree, each layer concatenates its pairs to result in half the number of leaf nodes (with the exception of the odd node). This means we can divide our current index by 2 and take the floor of it. (`Math.floor(2/2)` which is 1). \n\nSo now we move to index 1 on the second layer, which is `CD`. We need to again check if `CD` is a left or right node. Since it's an odd number, it's a right node. We'll subtract one to get it's left node `AB` and add it to our proof:\n\nOur proof so far: `[{ data: 'D', left: false }, { data: 'AB', left: true }]`\n\nIf we repeat this pattern, we'll divide our index (1) by 2, take the floor (0) and be at `ABCD`. We'll grab the right node `E` and add that to our proof:\n\n```\n[\n { data: 'D', left: false },\n { data: 'AB', left: true },\n { data: 'E', left: false }\n]\n```\n\nAnd we're done! ",
  "language": "javascript",
  "language_version": "8.x/babel",
  "position": 3,
  "task": "## Build The Proof\n\nAlright, now it's time to build the proof that a particular leaf node exists within a merkle tree! \n\nWith this proof, we'll only want to include the necessary hashes we need to create the root hash from our target leaf node.\n\n## Add the getProof Method\n\nLet's add a `getProof` method to our Merkle Tree, this function will take in an index of a leaf node and give us back a merkle proof, which is the minimum necessary hashes we'll need to prove the leaf node belongs in the tree.\n\nCheck out the example below or [follow our Recommended Approach](?tab=details&scroll=Recommended%20Approach).\n\n### ABCDE Merkle Tree Example\n\n```\n      Root\n     /    \\\n    ABCD   E\n    / \\    |\n   AB  CD  E\n  / \\  / \\ |\n  A B  C D E\n```\n\n**Proof of C**\n\nTo Prove `C` can build the Merkle Root, we can look at the path we need to take to hash up to the root:\n\n```\nHash(Hash(AB + Hash(C + D)) + E)\n```\n\nSo the four hashes in use here are `AB`, `C`, `D`, and `E`. Since we're starting with `C`, we don't need that node in the proof. We'll need to know the hashes `AB`, `D` and `E`. \n\nAlso (and this is important!) we need to know the order in which they should be hashed. `Hash(A + B)` will not be the same as `Hash(B + A)`. Our proof should contain the `data` (the hash) and whether or not the node is in the `left` position. \n\nOur resulting proof would look like this:\n\n```\n[\n { data: 'D', left: false },\n { data: 'AB', left: true },\n { data: 'E', left: false }\n]\n```\n\nBy looking at that proof, we can easily concatenate to the root. We start with `C`, concatenate `D` on the right (`CD`), concatenate `AB` to the left (`ABCD`) and then concatenate `E` on the right to get the root `ABCDE`. \n\nLook at that! We didn't even need to know `A` or `B`, just the combined hash of the two. \n\nCheck out Details for [another example](?tab=details&scroll=Another%Example).",
  "test_framework": "mocha_bdd",
  "title": "Build the Proof",
  "updated_at": "2018-10-16T01:50:10.741Z",
  "created_at": "2018-10-16T01:50:10.741Z"
}