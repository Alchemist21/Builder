{
  "_id": "5bc8b081626daf9c54d6129c",
  "_type": "CodeStage",
  "container_id": "5bb2c8ded9f99705a60c62d3",
  "title": "Transfer Debt?",
  "position": 4,
  "validated_contract": "Token",
  "language_version": "0.1.0b3",
  "language": "vyper",
  "test_framework": "truffle_with_mocha",
  "updated_at": "2018-10-25T16:54:07.515Z",
  "created_at": "2018-10-18T16:10:41.057Z",
  "code_file_ids": [
    "5bc8b130626daf9c54d612a0",
    "5bb2d834d9f99705a60c6308"
  ],
  "task": "## Wait a minute.\n\nWhat happens if someone tries to send **tokens they don't have**? Does your current `transfer` function handle this case?\n\nIt might, actually.\n\nRemember one of Vyper's goals is **Security**. Vyper wants to make it extra hard for you to write insecure code. For that reason you cannot [underflow](?tab=details&scroll=Integer%20Underflow) or overflow a number. \n\nLet's consider the case where we have two unsigned integers and we subtract the larger one from the smaller one:\n\n```\na: uint256\nb: uint256\nc: uint256\n\n@public\ndef setValues():\n  self.a = 5\n  self.b = 10\n  self.c = self.a - self.b\n```\n\nIn this case `a` is smaller than `b` and both are unsigned integers. Since the subtraction would result in a number below the unsigned integer range, \nthis transaction will revert every time. None of the state transitions within the transaction will be persisted.\n\nWe've set up the test cases so one account tries to transfer tokens it doesn't have to another account. Go ahead and test if your code handles this case!",
  "details": "## Integer Underflow\n\nRemember how we talked about `uint256` storing a range of values from `0` to `2^256 - 1`? \n\nWhat happens when we go below `0`? In most languages, this would result in an underflow and the binary value would go from 256 zeros:\n\n```\n0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n```\n\nto 256 ones:\n\n```\n1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 \n```\n\nWhich would mean suddenly the tokens wouldn't be `-1`, but `2^256`! How terrible! \n\nFortunately, in Vyper safe math is built in. This isn't something we have to worry about. ",
  "completion_message": ""
}