{
  "_id": "5bc8af83626daf9c54d6129a",
  "_type": "CodeStage",
  "container_id": "5bb2c8ded9f99705a60c62d3",
  "title": "Balancing Act",
  "position": 2,
  "validated_contract": "Token",
  "language_version": "0.1.0b3",
  "language": "vyper",
  "test_framework": "truffle_with_mocha",
  "updated_at": "2018-11-08T02:51:29.184Z",
  "created_at": "2018-10-18T16:06:27.953Z",
  "code_file_ids": [
    "5bc8b0ec626daf9c54d6129e",
    "5bb2d834d9f99705a60c6308"
  ],
  "abi_validations": [
    {
      "_id": "5bd1f77a626daf1162be4bf7",
      "constant": "true",
      "payable": "false",
      "error": null,
      "task_display": "Create a public 'balances' mapping",
      "name": "balances",
      "type": "function",
      "outputs": [
        {
          "_id": "5bd1f77a626daf1162be4bf8",
          "name": null,
          "type": "uint256"
        }
      ],
      "inputs": [
        {
          "_id": "5bd1f77a626daf1162be4bf9",
          "name": null,
          "type": "address"
        }
      ]
    }
  ],
  "task": "## Let's keep the balances \n\nNow it's time to keep track of each person's balance of the token.\n \nTo begin with, let's set the balance of the [address](?tab=details&scroll=Addresses) that deploys the contract to have all of the tokens.\n\n### Balances\n\nLet's create a [mapping](?tab=details&scroll=Mapping) called `balances` that will associate or \"map\" an `address` to a `uint256` balance.\n\nOnce you have created the public `balances` mapping you should notice the validation has been checked. \n\n## Set the Owner's Balance\n\nFor our simple token implementation, weâ€™re going to transfer the token supply to the address that deployed the contract.\n\nWe can do this using the `msg.sender` global which gives us access to the address of the person running the transaction. \n",
  "details": "## Addresses\n\nIn Ethereum, we can have access to our own currency and assets through an `address` on the blockchain that is specifically ours. \n\nA person can own an address by having their own **private key** which allows them to sign messages and prove their ownership. The network can check the signature against a published **public key**.\n\n> There are plenty of good resources to learn about [public key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography). A deep understanding is not entirely necessary for this lesson, although it certainly can be useful!\n\nAn address is typically shown as a 40 character hexadecimal string by convention like so: `0xf35074bbd0a9aee46f4ea137971feec024ab704e`. \n\nIn Vyper, we can store and refer to addresses using the `address` keyword. The address can be an individual or it can be another\ncontract, both of which we are able to send funds or tokens. In addition, if the address is a contract, we are able to call the methods on that contract at that address.\n\n## Mapping\n\nMappings are super crucial data structures in most smart contracts. They allow us to take a value and map it to some other value. The simplest case is a mapping of an address to some value. \n\nTake for instance, a mapping of addresses to balances:\n\n```\nbalances: uint256[address]\n```\n\nWe can imagine the contents of this mapping to look something like this:\n\n| address | balance  | \n|:---:|:---:|\n| `0xa201fe...`  |  100 |\n| `0xbeef31...` |  25 |\n| `0x001337...`  |  10 |\n\nGiven an address `0xbeef31...`, we can quickly look up and see that the balance is `25`:\n\n```\nlookup = balances[address]\n```\n\nTo set a balance we can set the value of balances at that address:\n\n```\nbalances[address] = 15\n```",
  "completion_message": "## We'll just call you Acrobat\n\nBecause you've got the balance! \n\nAwesome. Now let's spread the love around. "
}